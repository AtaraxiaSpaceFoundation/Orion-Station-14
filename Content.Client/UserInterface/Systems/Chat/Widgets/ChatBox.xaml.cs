// SPDX-FileCopyrightText: 2022 Chief-Engineer <119664036+Chief-Engineer@users.noreply.github.com>
// SPDX-FileCopyrightText: 2022 Flipp Syder <76629141+vulppine@users.noreply.github.com>
// SPDX-FileCopyrightText: 2022 Jezithyr <Jezithyr.@gmail.com>
// SPDX-FileCopyrightText: 2022 Jezithyr <Jezithyr@gmail.com>
// SPDX-FileCopyrightText: 2022 Jezithyr <jmaster9999@gmail.com>
// SPDX-FileCopyrightText: 2022 Visne <39844191+Visne@users.noreply.github.com>
// SPDX-FileCopyrightText: 2022 jicksaw <jicksaw@pm.me>
// SPDX-FileCopyrightText: 2022 wrexbe <81056464+wrexbe@users.noreply.github.com>
// SPDX-FileCopyrightText: 2022 wrexbe <wrexbe@protonmail.com>
// SPDX-FileCopyrightText: 2023 DrSmugleaf <DrSmugleaf@users.noreply.github.com>
// SPDX-FileCopyrightText: 2023 Leon Friedrich <60421075+ElectroJr@users.noreply.github.com>
// SPDX-FileCopyrightText: 2023 Pieter-Jan Briers <pieterjan.briers@gmail.com>
// SPDX-FileCopyrightText: 2023 metalgearsloth <31366439+metalgearsloth@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 0x6273 <0x40@keemail.me>
// SPDX-FileCopyrightText: 2024 Nikolai Korolev <CrafterKolyan@mail.ru>
// SPDX-FileCopyrightText: 2024 Pieter-Jan Briers <pieterjan.briers+git@gmail.com>
// SPDX-FileCopyrightText: 2024 Piras314 <p1r4s@proton.me>
// SPDX-FileCopyrightText: 2024 RedFoxIV <38788538+RedFoxIV@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 Winkarst <74284083+Winkarst-cpu@users.noreply.github.com>
// SPDX-FileCopyrightText: 2025 Aiden <28298836+Aidenkrz@users.noreply.github.com>
// SPDX-FileCopyrightText: 2025 Aidenkrz <aiden@djkraz.com>
// SPDX-FileCopyrightText: 2025 GoobBot <uristmchands@proton.me>
// SPDX-FileCopyrightText: 2025 Ted Lukin <66275205+pheenty@users.noreply.github.com>
// SPDX-FileCopyrightText: 2025 gluesniffler <159397573+gluesniffler@users.noreply.github.com>
// SPDX-FileCopyrightText: 2025 gluesniffler <linebarrelerenthusiast@gmail.com>
//
// SPDX-License-Identifier: AGPL-3.0-or-later

using System.Text.RegularExpressions;
using Content.Client.UserInterface.Systems.Chat.Controls;
using Content.Goobstation.Common.CCVar;
using Content.Shared._Europa; // Goobstation Change
using Content.Shared.Chat;
using Content.Shared.Input;
using Robust.Client.Audio;
using Robust.Client.AutoGenerated;
using Robust.Client.UserInterface;
using Robust.Client.UserInterface.Controls;
using Robust.Client.UserInterface.XAML;
using Robust.Shared.Audio;
using Robust.Shared.Configuration;
using Robust.Shared.Input;
using Robust.Shared.Player;
using Robust.Shared.Utility;
using static Robust.Client.UserInterface.Controls.LineEdit;

namespace Content.Client.UserInterface.Systems.Chat.Widgets;

[GenerateTypedNameReferences]
[Virtual]
public partial class ChatBox : UIWidget
{
    [Dependency] private readonly IEntityManager _entManager = default!;
    [Dependency] private readonly ILogManager _log = default!;

    private readonly ISawmill _sawmill;
    private readonly ChatUIController _controller;
    private readonly IConfigurationManager _cfg; // WD EDIT
    private readonly ILocalizationManager _loc; // WD EDIT

    public bool Main { get; set; }

    public ChatSelectChannel SelectedChannel => ChatInput.ChannelSelector.SelectedChannel;
    // WD EDIT START
    private bool _coalescence = false; // op ult btw
    private (string, Color)? _lastLine;
    private int _lastLineRepeatCount = 0;
    // WD EDIT END

    private static readonly Regex BubbleContentRegex = new Regex(
        @"\[BubbleContent\](.*?)\[/BubbleContent\]",
        RegexOptions.Singleline | RegexOptions.Compiled
    );

    public ChatBox()
    {
        RobustXamlLoader.Load(this);
        _sawmill = _log.GetSawmill("chat");
        _loc = IoCManager.Resolve<ILocalizationManager>();

        ChatInput.Input.OnTextEntered += OnTextEntered;
        ChatInput.Input.OnKeyBindDown += OnInputKeyBindDown;
        ChatInput.Input.OnTextChanged += OnTextChanged;
        ChatInput.Input.OnFocusEnter += OnFocusEnter;
        ChatInput.Input.OnFocusExit += OnFocusExit;
        ChatInput.ChannelSelector.OnChannelSelect += OnChannelSelect;
        ChatInput.FilterButton.Popup.OnChannelFilter += OnChannelFilter;
        ChatInput.FilterButton.Popup.OnNewHighlights += OnNewHighlights;
        _controller = UserInterfaceManager.GetUIController<ChatUIController>();
        _controller.MessageAdded += OnMessageAdded;
        _controller.HighlightsUpdated += OnHighlightsUpdated;
        _controller.RegisterChat(this);

        // WD EDIT START
        _cfg = IoCManager.Resolve<IConfigurationManager>();
        _coalescence = _cfg.GetCVar(GoobCVars.CoalesceIdenticalMessages); // i am uncomfortable calling repopulate on chatbox in its ctor, even though it worked in testing i'll still err on the side of caution
        _cfg.OnValueChanged(GoobCVars.CoalesceIdenticalMessages, UpdateCoalescence, false); // eplicitly false to underline the above comment
        // WD EDIT END
    }

    private void UpdateCoalescence(bool value) { _coalescence = value; Repopulate(); } // WD EDIT

    private void OnTextEntered(LineEditEventArgs args)
    {
        _controller.SendMessage(this, SelectedChannel);
    }

    private void OnMessageAdded(ChatMessage msg)
    {
        _sawmill.Debug($"{msg.Channel}: {msg.Message}");
        if (!ChatInput.FilterButton.Popup.IsActive(msg.Channel))
        {
            return;
        }

        if (msg is { Read: false, AudioPath: { } })
            _entManager.System<AudioSystem>().PlayGlobal(msg.AudioPath, Filter.Local(), false, AudioParams.Default.WithVolume(msg.AudioVolume));

        msg.Read = true;

        var color = msg.MessageColorOverride ?? msg.Channel.TextColor();

        // WD EDIT START
        (string, Color) tup = (msg.WrappedMessage, color);

        // Removing and then adding insantly nudges the chat window up before slowly dragging it back down, which makes the whole chat log shake
        // and make it borderline unreadable with frequent enough spam.
        // Adding first and then removing does not produce any visual effects.
        // The other option is to copypaste into Content all of OutputPanel and everything it uses but is intertanl to Robust namespace.
        // Thanks robustengine, very cool.
        if (_coalescence && _lastLine == tup)
        {
            if (!msg.CanCoalesce) // Goobstation Edit - Coalescing Chat
                return;

            _lastLineRepeatCount++;
            AddLine(msg.WrappedMessage, color, _lastLineRepeatCount);
            Contents.RemoveEntry(^2);
        }
        else
        {
            _lastLineRepeatCount = 0;
            _lastLine = (msg.WrappedMessage, color);
            AddLine(msg.WrappedMessage, color, _lastLineRepeatCount);
        } // WD EDIT END
    }

    private FormattedMessage ExtractAndFormatSpeechSubstring(string message,
        string tag,
        Color? fontColor = null)
    {
        var text = SharedChatSystem.GetStringInsideTag(message, tag);
        var result = FormatMessageWithFallback(text, fontColor);
        return result;
    }


    private FormattedMessage FormatMessageWithFallback(string message, Color? fontColor = null)
    {
        var msg = new FormattedMessage();
        if (fontColor != null)
            msg.PushColor(fontColor.Value);

        try
        {
            msg.AddMarkupOrThrow(message);
        }
        catch (Exception e)
        {
            msg.AddText(FuckHelper.EscapeSpecialCharacters(message));
        }

        return msg;
    }

    private void OnHighlightsUpdated(string highlights)
    {
        ChatInput.FilterButton.Popup.UpdateHighlights(highlights);
    }

    private void OnChannelSelect(ChatSelectChannel channel)
    {
        _controller.UpdateSelectedChannel(this);
    }

    public void Repopulate()
    {
        ClearChatContent();

        foreach (var message in _controller.History)
        {
            OnMessageAdded(message.Item2);
        }
    }

    private void OnChannelFilter(ChatChannel channel, bool active)
    {
        ClearChatContent();

        foreach (var message in _controller.History)
        {
            OnMessageAdded(message.Item2);
        }

        if (active)
        {
            _controller.ClearUnfilteredUnreads(channel);
        }
    }

    private void ClearChatContent()
    {
        Contents.Clear();

        foreach (var child in Contents.Children)
        {
            if (child.Name != "_v_scroll")
            {
                Contents.RemoveChild(child);
            }
        }
    }

    private void OnNewHighlights(string highlighs)
    {
        _controller.UpdateHighlights(highlighs);
    }

    public void AddLine(string message, Color color, int repeat = 0)
    {
        var formatted = new FormattedMessage(5); // WD EDIT // specifying size beforehand smells like a useless microoptimisation, but i'll give them the benefit of doubt
        formatted.PushColor(color);

        var sanitizedMessage = ExtractAndSanitizeBubbleContent(message);
        formatted.AddMessage(sanitizedMessage);

        formatted.Pop();

        if(repeat != 0) // WD EDIT START
        {
            int displayRepeat = repeat + 1;
            int sizeIncrease = Math.Min(displayRepeat / 6, 5);

            var repeatText = _loc.GetString("chat-system-repeated-message-counter",
                ("count", displayRepeat),
                ("size", 8 + sizeIncrease)
            );

            try
            {
                formatted.AddMarkupOrThrow(repeatText);
            }
            catch (Exception e)
            {
                _sawmill.Warning(Loc.GetString("chat-repeat-parse-error", ("message", repeatText)));
                _sawmill.Error(e.Message);
            }
        } // WD EDIT END

        Contents.AddMessage(formatted);
    }

    private FormattedMessage ExtractAndSanitizeBubbleContent(string message)
    {
        var result = new FormattedMessage();

        try
        {
            if (BubbleContentRegex.IsMatch(message))
            {
                var processedMessage = BubbleContentRegex.Replace(message,
                    match =>
                {
                    var originalContent = match.Groups[1].Value;

                    if (string.IsNullOrEmpty(originalContent))
                        return match.Value;

                    var sanitizedContent = FuckHelper.SanitizeSimpleMessageForChat(originalContent);
                    return $"[BubbleContent]{sanitizedContent}[/BubbleContent]";
                });

                result.AddMarkupOrThrow(processedMessage);
            }
            else
            {
                result.AddMarkupOrThrow(message);
            }
        }
        catch (Exception ex)
        {
            var sanitizedMessage = FuckHelper.SanitizeSimpleMessageForChat(message);
            result.AddText(sanitizedMessage);
        }

        return result;
    }

    public void Focus(ChatSelectChannel? channel = null)
    {
        var input = ChatInput.Input;
        var selectStart = Index.End;

        if (channel != null)
            ChatInput.ChannelSelector.Select(channel.Value);

        input.IgnoreNext = true;
        input.GrabKeyboardFocus();

        input.CursorPosition = input.Text.Length;
        input.SelectionStart = selectStart.GetOffset(input.Text.Length);
    }

    public void CycleChatChannel(bool forward)
    {
        var idx = Array.IndexOf(ChannelSelectorPopup.ChannelSelectorOrder, SelectedChannel);
        do
        {
            // go over every channel until we find one we can actually select.
            idx += forward ? 1 : -1;
            idx = MathHelper.Mod(idx, ChannelSelectorPopup.ChannelSelectorOrder.Length);
        } while ((_controller.SelectableChannels & ChannelSelectorPopup.ChannelSelectorOrder[idx]) == 0);

        SafelySelectChannel(ChannelSelectorPopup.ChannelSelectorOrder[idx]);
    }

    public void SafelySelectChannel(ChatSelectChannel toSelect)
    {
        toSelect = _controller.MapLocalIfGhost(toSelect);
        if ((_controller.SelectableChannels & toSelect) == 0)
            return;

        ChatInput.ChannelSelector.Select(toSelect);
    }

    private void OnInputKeyBindDown(GUIBoundKeyEventArgs args)
    {
        if (args.Function == EngineKeyFunctions.TextReleaseFocus)
        {
            ChatInput.Input.ReleaseKeyboardFocus();
            ChatInput.Input.Clear();
            args.Handle();
            return;
        }

        if (args.Function == ContentKeyFunctions.CycleChatChannelForward)
        {
            CycleChatChannel(true);
            args.Handle();
            return;
        }

        if (args.Function == ContentKeyFunctions.CycleChatChannelBackward)
        {
            CycleChatChannel(false);
            args.Handle();
        }
    }

    private void OnTextChanged(LineEditEventArgs args)
    {
        // Update channel select button to correct channel if we have a prefix.
        _controller.UpdateSelectedChannel(this);

        // Warn typing indicator about change
        _controller.NotifyChatTextChange();
    }

    private void OnFocusEnter(LineEditEventArgs args)
    {
        // Warn typing indicator about focus
        _controller.NotifyChatFocus(true);
    }

    private void OnFocusExit(LineEditEventArgs args)
    {
        // Warn typing indicator about focus
        _controller.NotifyChatFocus(false);
    }

    protected override void Dispose(bool disposing)
    {
        base.Dispose(disposing);

        if (!disposing) return;
        _controller.UnregisterChat(this);
        ChatInput.Input.OnTextEntered -= OnTextEntered;
        ChatInput.Input.OnKeyBindDown -= OnInputKeyBindDown;
        ChatInput.Input.OnTextChanged -= OnTextChanged;
        ChatInput.ChannelSelector.OnChannelSelect -= OnChannelSelect;
        _cfg.UnsubValueChanged(GoobCVars.CoalesceIdenticalMessages, UpdateCoalescence); // WD EDIT
    }
}
